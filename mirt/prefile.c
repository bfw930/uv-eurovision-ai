/* This program reads the binary "pre-file" generated by 
   "preprocessmidimels.tcl" which stores each interval as:
   pitch difference + 127, with 255 reserved for rests
   rhythm contour (L=longer, S=shorter, R=remain the same)
   stress contour (L=louder, S=softer, R=remain the same)

   Rests don't have a stress contour byte
*/
#define debug 0
#define DEBUG 0
#define debugstat 0

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/mman.h>

/*#include "top.h"*/
#include "melcmp.h"

#include "melodies.h"
#include "melsim.h"
#include "general.h"
#include "prefile.h"



SONG *initSong()
{
SONG *song; 
if( ! (song = (SONG *) malloc( sizeof( SONG ) ) ) )
   doError( "Failed to allocate space for SONG structure\n" );
if( ! (song->notes = (NOTE **) malloc( sizeof( NOTE * ) * NOTEBUFLENGTH ) ) )
   doError( "Failed to allocate space for SONG structure's notes\n" );
song->storageLength = NOTEBUFLENGTH;
return song;
}

void freeSong( SONG *song )
{
int i;
NOTE **notes;

free( song->fileName);
notes = song->notes;
for( i=0; i<song->songLength; i++ )
 {
  free( *notes++ );
 }
free( song->notes );
free( song );
}

char *putFileInMemory( char *filename, int *fsize, FLAGS myflags )
{
int fd = open( filename, O_RDONLY );
struct stat *fileDetails;
char *startpt;
int filesize, ret;

if( myflags.debuglevel >= 1 )
  printf( "putFileInMemory called with filename %s\n", filename );
/* Open file and use mmap to map it into memory 
*/
if( fd == -1 )
  {
  fprintf( stderr, "File name was %s, ", filename );
  doError( "Failed to open file\n" );
  }
 if( ! (fileDetails = (struct stat *)
       malloc( sizeof( struct stat ) ) ) )
  doError("Error: Failed to allocate space for stat structure\n" );
 if( fstat( fd, fileDetails ) )
   {
     fprintf( stderr, "Errno is %d\n", errno );
     doError( "Error: Failed to call stat for database file\n" );
   }
filesize = fileDetails->st_size;

#if debugstat
 printf( "File size in bytes is %d\n", filesize );
#endif
if( myflags.debuglevel >= 1 )
  printf( "opened file, about to mmap\n" );
startpt = (char *) mmap( (void *)0, filesize, PROT_READ, 0, fd, 0 );
if( startpt == MAP_FAILED ) 
  {
    printf( "Error number is %d\n", errno );
    doError( "Failed mmap\n" );
  }
if( myflags.debuglevel >= 1 )
  printf( "file is mmapped\n" );
if( ( ret = close( fd ) ) )
  doError("Problem closing file\n" );
free( fileDetails );
*fsize = filesize;
return startpt;
}

SONG *getSongFile( char *filename, int maxLength, FLAGS myflags )
{
int fd;
unsigned char ch, rhythm, stress, pitch;
int i = 0, allocCount = 1, currentStore, ret;
static int failCloseCount = 0;
NOTE *note, **notesptr;
SONG *song;
char *startpt, *endpt;
register char *memfileptr; 
int filesize;

#if DEBUG
printf("getSongFile called with filename %s and maxLength %d\n", 
  filename, maxLength ); 
#endif

startpt = putFileInMemory( filename, &filesize, myflags );
song = initSong();
song->fileName = strdup( filename );
currentStore = NOTEBUFLENGTH;

notesptr = song->notes;

#if DEBUG
printf( "song->notes is %d, notesptr is %d\n", song->notes, notesptr );
#endif
 
endpt = startpt + filesize;
memfileptr = startpt;
/* get char until EOF */
while( memfileptr != endpt && i < maxLength )
  {
    pitch = *memfileptr++;
    /* if we run out of space, reallocate it and redefine our size */
    if( i >= currentStore )
      {
	currentStore += NOTEBUFLENGTH;
	if( ! (song->notes = realloc( song->notes, ( sizeof( NOTE * ) 
			   * currentStore ) ) ) )
	  {
	    fprintf( stderr, "failed on song %s with currentStore %d\n",
		     filename, currentStore );
	  doError( "Failed reallocation of NOTES memory\n" );
	  }
	notesptr = song->notes + i;
	}
    /* If it's a note, read note info, otherwise read rest info */
    if( pitch != 255 )
      {
        if( memfileptr == endpt )
	  doError( "Incomplete note information\n" );
	rhythm = *memfileptr++;
        if( memfileptr == endpt )
	  doError( "Incomplete note information\n" );
	stress = *memfileptr++;
#if debug
	printf( "Note: pitch = %x, rhythm = %c, stress = %c\n", pitch, 
		rhythm, stress );
#endif
      }
    else /* read rest info */
      {
        if( memfileptr == endpt )
	  doError( "Incomplete note information\n" );
	rhythm = *memfileptr++;
#if debug
	printf( "Rest: pitch = %x, rhythm = %c\n", pitch, 
		rhythm );
#endif
      }
    /* store the info into our note structure */
    if( ! (note = (NOTE *) malloc( sizeof( NOTE ) ) ) )
     doError( "Failed to allocate space for NOTE structure\n" );
    note->interval = pitch;
    note->rhythm = rhythm;
    note->stress = stress;
    *notesptr++ = note;
    i++;
  }
song->storageLength = currentStore;
song->songLength = i; 
#if DEBUG
printf( "songlength in structure is %d and maxlength is %d\n", song->songLength,
	maxLength );
#endif 
if( munmap( startpt, filesize ) )
    fprintf( stderr, "Problem calling munmap\n" );
return song;
}

void displayMelody( SONG *song )
{
int i;
NOTE *note;

printf("displayMelody called with data pointer = %d\n", song );
printf( "Song file: %s\n", song->fileName );
printf( "Number of notes: %d\n", song->songLength );
printf( "Note Storage: %d\n", song->storageLength );
printf( "\nNotes\n=====\n" );
for( i=0; i < song->songLength; i++ )
  {
    note = song->notes[i];
    printf( "%d\t%c", note->interval, note->rhythm );
    if( note->interval == 255 )
      printf( "\n" );
    else
      printf( "\t%c\n", note->stress );
  }
}

char *getContourString( SONG *song, FLAGS myflags )
{
register int i;
char string[song->songLength + 1], *retStr;
NOTE *note;
char *str = string;

for( i=0; i < song->songLength;i++ )
  {
    note = song->notes[i];
    if( note->interval != 255 )
      /* Skip rests */
      {
	if( note->interval > 127 )
	  *str++ = 'U';
	else if( note->interval < 127 )
	  *str++ = 'D';
	else
	  *str++ = 'R';
      }
    else if( myflags.rests )
      *str++ = '.';
  }
*str = '\0'; /* set last char to null char */
retStr = strdup( string );
return retStr;
}

char *getContourPlusRhythmString( SONG *song, FLAGS myflags )
{
register int i;
char string[2 * song->songLength + 1], *retStr;
NOTE *note;
char *str = string;
char prevrhythm;

for( i=0; i < song->songLength;i++ )
  {
    note = song->notes[i];
    if( note->interval != 255 )
      /* Skip rests */
      {
	if( note->interval > 127 )
	  *str++ = 'U';
	else if( note->interval < 127 )
	  *str++ = 'D';
	else
	  *str++ = 'R';
      }
    else if( myflags.rests )
      {
	*str++ = '.';
	*str++ = (char) note->rhythm;
      }
    if( note->interval != 255 && !myflags.rests && i>0 )
      { /* 
	   Deal with skipped rest and rhythm contour info adjustment.
	   Note that some info is lost when we have L followed by S and v.v.
	 */
	prevrhythm = (char) song->notes[i-1]->rhythm;
	if( song->notes[i-1]->interval == 255 )
	  {
	    if( note->rhythm == 'R' )
	      *str++ =  prevrhythm;
	    else if( ( note->rhythm == 'L' && prevrhythm == 'S' )
		     || ( note->rhythm == 'S' && prevrhythm == 'L' ) )
	      *str++ = 'R';
	    else
	      *str++ = (char) note->rhythm;
	  }
	else
	  *str++ = (char) note->rhythm;
      }
    else if( note->interval != 255 && !myflags.rests && !i )
      *str++ = (char) note->rhythm;
  }
*str = '\0'; /* set last char to null char */
retStr = strdup( string );
return retStr;
}

int addRhythm( char rhythm )
{
switch( rhythm )
  {
  case 'R':
    return -32;
  case 'S':
    return 32;
  case 'L':
  default:
    return 0;
  }
}


char *getContourRhythmComboString( SONG *song, FLAGS myflags )
{
register int i;
char string[2 * song->songLength + 1], *retStr;
NOTE *note;
char *str = string;
char prevrhythm, rhythm;
short interval, previnterval;

for( i=0; i < song->songLength;i++ )
  {
    note = song->notes[i];
    interval = note->interval;
    rhythm = note->rhythm;
    if( interval != 255 )
      /* Skip rests */
      {
	if( interval > 127 )
	  *str = 'U';
	else if( interval < 127 )
	  *str = 'D';
	else
	  *str = 'R';
      }
    else if( myflags.rests )
      {
	*str = '^';
      }
    if( myflags.rests || !i )
      *str += addRhythm( rhythm );
    else if( interval != 255 && !myflags.rests && i>0 )
      { /* 
	   Deal with skipped rest and rhythm contour info adjustment.
	   Note that some info is lost when we have L followed by S and v.v.
	 */
	if( previnterval == 255 )
	  {
	    if( rhythm == 'R' )
	      *str += addRhythm( prevrhythm );
	    else if( ( rhythm == 'L' && prevrhythm == 'S' )
		     || ( rhythm == 'S' && prevrhythm == 'L' ) )
	      *str += addRhythm( 'R' );
	    else
	      *str += addRhythm( rhythm );
	  }
	else
	  *str +=  addRhythm( rhythm );
      }
    else if( interval != 255  )
      *str += addRhythm( rhythm );
    prevrhythm = rhythm;
    previnterval = interval;
    if( myflags.rests || interval != 255 )
      str++;
  }
*str = '\0'; /* set last char to null char */
retStr = strdup( string );
return retStr;
}


char *getModDirString( SONG *song, FLAGS myflags )
{
register int i;
int interval, unshiftedInterval;
char *string, *retStr;
NOTE *note;
char *str = string;

#if DEBUG
printf("getModDirString called with songlength %d\n", song->songLength );
#endif 
if( !(string = (char *)malloc( sizeof( char ) * (song->songLength + 1) ) ) )
  doError( "Failed to allocate space for song string\n" );
str = string;
for( i=0; i < song->songLength;i++ )
  {
    note = song->notes[i];
    interval = note->interval;
    if( interval != 255 )
      /* Skip rests */
      {
	unshiftedInterval = interval - 127;
	if( unshiftedInterval % 12 == 0 && unshiftedInterval > 0 ) /* ^8ve */
	  *str++ = (char) ( 12 + (int)'m' );
	else if( unshiftedInterval % 12 == 0 && unshiftedInterval < 0 ) 
	  *str++ = (char) ( (int)'m' - 12 );
	else if( interval >= 127 )
	  *str++ = (char) ( (interval - 127) % 12 + (int)'m' );
	else
	  *str++ = (char) ( (int) 'm' - (127 - interval) % 12 );
      }
    else if( myflags.rests )
      *str++ = '.';
  }
 *str++ = '\0'; /* set last char to null char */
retStr = strdup( string );
#if DEBUG
printf( "returning from getModDirString\n" );
#endif 
return retStr;
}


char *getModDirPlusRhythmString( SONG *song, FLAGS myflags )
{
register int i;
int interval;
char *string, *retStr;
NOTE *note;
char *str = string;
char prevrhythm;

#if DEBUG
printf("getModDirString called with songlength %d\n", song->songLength );
#endif 
if( !(string = (char *)malloc( 2 * sizeof( char ) * (song->songLength + 1) ) ) )
  doError( "Failed to allocate space for song string\n" );
str = string;
for( i=0; i < song->songLength;i++ )
  {
    note = song->notes[i];
    interval = note->interval;
    if( interval != 255 )
      /* Skip rests */
      {
	if( interval >= 127 )
	  *str++ = (char) ( (interval - 127) % 12 + (int)'m' );
	else
	  *str++ = (char) ( (int) 'm' - (127 - interval) % 12 );
      }
    else if( myflags.rests )
      {
	*str++ = '.';
	*str++ = (char) note->rhythm;
      }
    if( interval != 255 && !myflags.rests && i>0 )
      { /* 
	   Deal with skipped rest and rhythm contour info adjustment.
	   Note that some info is lost when we have L followed by S and v.v.
	 */
	prevrhythm = (char) song->notes[i-1]->rhythm;
	if( song->notes[i-1]->interval == 255 )
	  {
	    if( note->rhythm == 'R' )
	      *str++ =  prevrhythm;
	    else if( ( note->rhythm == 'L' && prevrhythm == 'S' )
		     || ( note->rhythm == 'S' && prevrhythm == 'L' ) )
	      *str++ =  'R';
	    else
	      *str++ = (char) note->rhythm;
	  }
	else
	  *str++ = (char) note->rhythm;
      }
    else if( note->interval != 255 && !myflags.rests && !i )
      *str++ = (char) note->rhythm;
  }
 *str++ = '\0'; /* set last char to null char */
retStr = strdup( string );
return retStr;
}


char *getModDirRhythmComboString( SONG *song, FLAGS myflags )
{
register int i;
char *string, *retStr;
NOTE *note;
char *str = string;
char prevrhythm, rhythm;
short interval, previnterval;

#if DEBUG
printf("getModDirComboString called with songlength %d\n", song->songLength );
#endif 
if( !(string = (char *)malloc( 2 * sizeof( char ) * (song->songLength + 1) ) ) )
  doError( "Failed to allocate space for song string\n" );
str = string;
for( i=0; i < song->songLength;i++ )
  {
    note = song->notes[i];
    interval = note->interval;
    rhythm = note->rhythm;
    if( interval != 255 )
      /* Skip rests */
      {
	if( interval >= 127 )
	  *str = (char) ( (interval - 127) % 12 + (int)'M' );
	else
	  *str = (char) ( (int) 'M' - (127 - interval) % 12 );
      }
    else if( myflags.rests )
	*str = '^';
    if( myflags.rests || !i )
      *str += addRhythm( rhythm );
    else if( interval != 255 )
      { /* 
	   Deal with skipped rest and rhythm contour info adjustment.
	   Note that some info is lost when we have L followed by S and v.v.
	 */
	if( previnterval == 255 )
	  {
	    if( note->rhythm == 'R' )
	      *str +=  addRhythm( prevrhythm );
	    else if( ( rhythm == 'L' && prevrhythm == 'S' )
		     || ( rhythm == 'S' && prevrhythm == 'L' ) )
	      *str += addRhythm( 'R' );
	    else
	      *str += addRhythm( rhythm );
	  }
	else
	  *str +=  addRhythm( rhythm );
      }
    else if( interval != 255 )
      *str += addRhythm( rhythm );
    prevrhythm = rhythm;
    previnterval = interval;
    if( myflags.rests || interval != 255 )
      str++;
  }
 *str++ = '\0'; /* set last char to null char */
retStr = strdup( string );
return retStr;
}


char *getString( SONG *song, FLAGS myflags  )
{
char *retStr;

#if DEBUG
printf( "getString called\n" );
printf( "notetype is %c\n", myflags.notetype );
#endif 
switch( myflags.notetype )
  {
  case 'c': 
    retStr = getContourString( song, myflags  );
    break;
  case 'C':
    retStr = getContourRhythmComboString( song, myflags  );
    break;
  case 'D':
    retStr = getModDirRhythmComboString( song, myflags  );
    break;
  case 'd':
  default:
#if DEBUG
    printf( "in switch option 'd', about to call getModDirString\n" );
#endif 
    retStr = getModDirString( song, myflags  );
    break;
  }
return retStr;
}

short *getAbsArray( SONG *song, FLAGS myflags )
{
short i, j, interval, prev;
NOTE *note;
short *retArr;

if( ! (retArr  = (short *) malloc ( sizeof( song->songLength + 1 ) ) ) )
  doError( "Failed to allocate short array\n" );

#if DEBUG
printf( "getAbsArray called\n" );
#endif

retArr[0] = 0;
for( i=0, j=1; i < song->songLength;i++ )
  {
    note = song->notes[i];
    interval = note->interval;
    if( interval != 255 || myflags.rests )
      /* Skip rests */
      {
	  retArr[j] =  (interval - 127) + retArr[j-1];
	  j++;
      }
  }
return retArr;
}

unsigned char*getUCharArray( SONG *song, int *length, FLAGS myflags )
{
short i, j, interval, prev;
NOTE *note;
unsigned char *retArr;

if( ! (retArr  = (unsigned char *) malloc ( 
	      sizeof( unsigned char ) * song->songLength + 1 ) ) )
  doError( "Failed to allocate unsigned char array\n" );

#if DEBUG
printf( "getUCharArray called\n" );
#endif

for( i=0, j=0; i < song->songLength;i++ )
  {
    note = song->notes[i];
    interval = note->interval;
    if( interval != 255 || myflags.rests)
      /* Skip rests */
      {
	  retArr[j] = interval;
	  j++;
      }    
#if debug
printf( "getUCharArray j=%d, i=%d, interval=%d\n", j, i, interval );
#endif
  }
*length = j;

#if DEBUG
printf( "getUCharArray finished\n" );
#endif

return retArr;
}

int getSongLength( short *startpt, char *endpt )
{
  int i = 0;	
  short *intpt;

#if DEBUG
  printf( "getSongLength called\n" );
#endif
  intpt = (short *) startpt;
  while( *intpt != -1 && intpt < (short *)endpt )
   {
     i++;
     intpt++;
   }
  return i;
}

char *showMappedFile( char *startpt, int filesize )
{
char *endpt = startpt + filesize -1;
char *currpt = startpt, *name;
short *intpt;
while( currpt < endpt )
  {
    printf( "\nFilename is %s\nIntegers are:\n", currpt );
    currpt = strchr( currpt, '\0' ) + 1;
    intpt = (short *) currpt;
    while( *intpt != -1 && intpt < (short *)endpt )
      {
	printf( "%d ", *intpt++ );
      }
    intpt++;
    currpt = (char *)intpt;
  }
}

char *showMappedFile2( char *startpt, int filesize )
{
char *endpt = startpt + filesize -1;
char *currpt = startpt, *name;
unsigned char *intpt;
int *length, count;

while( currpt < endpt )
  {
    printf( "\nFilename is %s\nIntegers are:\n", currpt );
    currpt = strchr( currpt, '\0' ) + 1;
    length = (int *)currpt;
    count = *length;
    printf( "Length is %d\n", count );
    length++;
    currpt = (char *) length;
    intpt = (unsigned char *) currpt;
    while( count-- && intpt < (unsigned char *)endpt )
      {
	printf( "%d ", *intpt++ );
      }
    currpt = (char *)intpt;
  }
}

void showUChars( unsigned char *str, int length )
{
while( length-- )
  printf( "%02x ", *str++ );
printf( "\n" );
}



